import numpy as np
import matplotlib.pyplot as plt
from qiskit import Aer, QuantumCircuit
from qiskit.utils import QuantumInstance
from qiskit.algorithms import VQE
from qiskit.circuit.library import RealAmplitudes
from qiskit.opflow import PauliSumOp
from qiskit.algorithms.optimizers import SPSA

# ----------------------------
# 1. Systemparameter
# ----------------------------
num_qubits_per_particle = 2
num_particles = 3
total_qubits = num_qubits_per_particle * num_particles

kinetic_strength = 0.5
interaction_strength = -1.0
external_field_strength = 0.1

time_step = 0.1
trotter_steps = 5

# ----------------------------
# 2. Hamiltonian erstellen
# ----------------------------
hamiltonian_op = PauliSumOp.from_list([])

# Kinetische Energie
for i in range(num_particles):
    q_index = i * num_qubits_per_particle
    label = ["I"]*total_qubits
    label[q_index] = "Z"
    hamiltonian_op += PauliSumOp.from_list([("".join(label), kinetic_strength)])

# Wechselwirkungen
pairs = [(i,j) for i in range(num_particles) for j in range(i+1,num_particles)]
for (i,j) in pairs:
    q_i = i * num_qubits_per_particle
    q_j = j * num_qubits_per_particle
    label = ["I"]*total_qubits
    label[q_i] = "Z"
    label[q_j] = "Z"
    hamiltonian_op += PauliSumOp.from_list([("".join(label), interaction_strength)])

# Externe Felder
for q in range(total_qubits):
    label = ["I"]*total_qubits
    label[q] = "Z"
    hamiltonian_op += PauliSumOp.from_list([("".join(label), external_field_strength)])

# ----------------------------
# 3. VQE für Grundzustand
# ----------------------------
ansatz = RealAmplitudes(num_qubits=total_qubits, reps=2, entanglement='full')
backend = Aer.get_backend('statevector_simulator')
quantum_instance = QuantumInstance(backend)

energies = []
def store_energy(eval_count, params, energy, stddev):
    energies.append(energy)

optimizer = SPSA(maxiter=50)
vqe_solver = VQE(ansatz=ansatz,
                 optimizer=optimizer,
                 quantum_instance=quantum_instance,
                 callback=store_energy)

vqe_result = vqe_solver.compute_minimum_eigenvalue(operator=hamiltonian_op)
print("Approximierter Grundzustand (VQE-Energie):", vqe_result.eigenvalue.real)

plt.plot(energies, marker='o')
plt.xlabel("Iteration")
plt.ylabel("Energy")
plt.title("VQE Energy Convergence")
plt.grid(True)
plt.show()

# ----------------------------
# 4. Trotter-Zeitentwicklung
# ----------------------------
qc = QuantumCircuit(total_qubits)

# Initialzustand: Ground State von VQE
# (Hier nur symbolisch als Superposition; echte Statevector-Einspeisung erfordert Aer Statevector initial_state)
for q in range(total_qubits):
    qc.h(q)

for step in range(trotter_steps):
    # Wechselwirkungen
    for (i,j) in pairs:
        q_i = i * num_qubits_per_particle
        q_j = j * num_qubits_per_particle
        qc.rzz(2 * interaction_strength * time_step, q_i, q_j)
    # Kinetische Energie
    for i in range(num_particles):
        q_index = i * num_qubits_per_particle
        qc.rz(2 * kinetic_strength * time_step, q_index)
    # Externe Felder
    for q in range(total_qubits):
        qc.rz(2 * external_field_strength * time_step, q)

qc.measure_all()
print("\nQuantenschaltkreis für Trotter-Zeitentwicklung:")
print(qc.draw(fold=100))
