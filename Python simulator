"""
Universal Quantum-Chemistry Simulator (VQE + Trotter + Geodrift + Plotly)
Selbstständig lauffähiges Ein-Datei-Skript.

Funktionen:
- Automatische Active-Space-Reduktion (heuristisch)
- VQE-Grundzustand (robuste Importe für verschiedene Qiskit-Versionen)
- Zeitentwicklung via PauliTrotterEvolution + zeitabhängiges Geodrift-Feld
- Analyse: Zustandswahrscheinlichkeiten, Ein-Qubit-Entropien, Concurrence, Fidelity
- Interaktive Plotly-Animation + JSON-Export pro System

Getestet mit: qiskit 0.45–0.46, qiskit-nature 0.6, qiskit-aer, pyscf, plotly
"""

import json
import numpy as np
import plotly.graph_objects as go

# --- Qiskit (robuste Importe für alte/neuere APIs) ---------------------------
from qiskit import Aer, QuantumCircuit

# VQE & Optimizer: neuer Pfad (qiskit-algorithms) oder alter Fallback
try:
    from qiskit_algorithms import VQE
    from qiskit_algorithms.optimizers import COBYLA
    _ALG_NEW = True
except Exception:
    from qiskit.algorithms import VQE
    from qiskit.algorithms.optimizers import COBYLA
    _ALG_NEW = False

# QuantumInstance (ältere API). Neuere VQE kann mit Estimator arbeiten.
try:
    from qiskit.utils import QuantumInstance
    _HAS_QI = True
except Exception:
    _HAS_QI = False

# Estimator (neue API, optional)
try:
    from qiskit.primitives import Estimator
    _HAS_ESTIMATOR = True
except Exception:
    _HAS_ESTIMATOR = False

from qiskit.circuit.library import RealAmplitudes
from qiskit.opflow import StateFn, PauliTrotterEvolution
from qiskit.quantum_info import Statevector, partial_trace, entropy, state_fidelity
from qiskit.quantum_info.analysis import concurrence

# --- Qiskit Nature: API-Fallbacks -------------------------------------------
try:
    # neuere Struktur (0.6+)
    from qiskit_nature.drivers.second_quantization import PySCFDriver
    from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
    from qiskit_nature.mappers.second_quantization import ParityMapper
    from qiskit_nature.converters.second_quantization import QubitConverter
    from qiskit_nature.algorithms import GroundStateEigensolver
    from qiskit_nature.transformers import ActiveSpaceTransformer
    _NATURE_NEW = True
except Exception:
    # ältere Struktur (Fallback)
    from qiskit_nature.drivers import PySCFDriver
    from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
    from qiskit_nature.mappers.second_quantization import ParityMapper
    from qiskit_nature.converters.second_quantization import QubitConverter
    from qiskit_nature.algorithms import GroundStateEigensolver
    from qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer
    _NATURE_NEW = False

# --- Globale Parameter -------------------------------------------------------
GEODRIFT_AMPLITUDE = 0.2
TROTTER_STEPS = 5
TIME_STEP = 0.1
MAX_QUBITS = 20
BASIS_DEFAULT = "sto3g"  # für schnelle Tests; schwerere Atome brauchen größere/relativistische Basissets

# --- Utility-Funktionen ------------------------------------------------------
def geodrift(t, num_qubits, amplitude=GEODRIFT_AMPLITUDE):
    """Zeitabhängige Z-Rotationen mit Phasenversatz je Qubit."""
    phases = np.linspace(0, 2*np.pi, num_qubits, endpoint=False)
    return amplitude * np.sin(2*np.pi*t + phases)

def compute_von_neumann_entropy(statevector, qubit_index):
    """Ein-Qubit-Reduktion und Von-Neumann-Entropie (Basis 2)."""
    traced = partial_trace(statevector, [i for i in range(statevector.num_qubits) if i != qubit_index])
    return float(entropy(traced, base=2))

def compute_concurrence_matrix(sv: Statevector, num_qubits: int):
    """Concurrence für alle Qubit-Paare (symmetrische Matrix)."""
    matrix = np.zeros((num_qubits, num_qubits))
    if num_qubits < 2:
        return matrix
    for i in range(num_qubits):
        for j in range(i+1, num_qubits):
            reduced = partial_trace(sv, [k for k in range(num_qubits) if k not in [i, j]])
            try:
                val = concurrence(reduced)
            except Exception:
                val = 0.0
            matrix[i, j] = matrix[j, i] = float(val)
    return matrix

def determine_active_space(atom_list, max_qubits=MAX_QUBITS):
    """
    Sehr simple Heuristik:
    - Elektronen ~ 2 pro Atom (valenznah)
    - Anzahl Orbitale so, dass Qubitbudget grob eingehalten wird
    Hinweis: Für realistische Studien Active Space chemisch motiviert wählen!
    """
    est_electrons = max(2, 2*len(atom_list))
    num_orbitals = max(2, min(2*len(atom_list), max_qubits//2))
    return est_electrons, num_orbitals

# --- Kernsimulation ----------------------------------------------------------
def run_universal_molecule_simulation(atom_list, basis=BASIS_DEFAULT,
                                      trotter_steps=TROTTER_STEPS,
                                      time_step=TIME_STEP,
                                      geodrift_amplitude=GEODRIFT_AMPLITUDE):
    """
    - Baut lineare Geometrie (1.5 Å Abstand)
    - Active Space via Heuristik
    - VQE-Grundzustand
    - Trotter-Zeitentwicklung + Geodrift
    - JSON-Export + Rückgabe der Ergebnisse
    """
    # 1) Geometrie & Active Space
    geom_strings = [f"{atom} .0 .0 {i*1.5}" for i, atom in enumerate(atom_list)]
    geometry = "; ".join(geom_strings)
    active_electrons, active_orbitals = determine_active_space(atom_list, MAX_QUBITS)

    # 2) Nature-Problem + Transformer
    driver = PySCFDriver(atom=geometry, basis=basis)
    transformer = ActiveSpaceTransformer(num_electrons=active_electrons,
                                         num_molecular_orbitals=active_orbitals)
    es_problem = ElectronicStructureProblem(driver, transformers=[transformer])

    # 3) Fermion -> Qubit (Parity + 2-qubit reduction wenn möglich)
    hamiltonian = es_problem.second_q_ops()[0]
    mapper = ParityMapper()
    qubit_converter = QubitConverter(mapper=mapper, two_qubit_reduction=True)

    # num_particles für 2-qubit-reduction (API variiert; robust behandeln)
    try:
        if _NATURE_NEW:
            n_particles = es_problem.grouped_property_transformed.molecule_data_transformed.num_particles
        else:
            n_particles = es_problem.grouped_property_transformed.molecule.num_particles
        qubit_hamiltonian = qubit_converter.convert(hamiltonian, num_particles=n_particles)
    except Exception:
        qubit_hamiltonian = qubit_converter.convert(hamiltonian)

    num_qubits = qubit_hamiltonian.num_qubits
    name = "".join(atom_list)
    print(f"✅ {name}: Qubits nach Reduktion = {num_qubits} (Active e⁻={active_electrons}, Orbitale={active_orbitals}, Basis={basis})")

    # 4) VQE-Setup
    ansatz = RealAmplitudes(num_qubits=num_qubits, reps=2, entanglement='full')

    # VQE je nach API-Variante konfigurieren
    vqe_kwargs = {}
    if _HAS_QI:
        vqe_kwargs["quantum_instance"] = QuantumInstance(Aer.get_backend('aer_simulator_statevector'))
    elif _HAS_ESTIMATOR and _ALG_NEW:
        vqe_kwargs["estimator"] = Estimator()
    else:
        # Minimal-Fallback: Aer Statevector als Backend über legacy-API
        vqe_kwargs["quantum_instance"] = QuantumInstance(Aer.get_backend('aer_simulator_statevector'))

    vqe_solver = VQE(ansatz=ansatz, optimizer=COBYLA(), **vqe_kwargs)
    gs_solver = GroundStateEigensolver(qubit_converter, vqe_solver)
    vqe_result = gs_solver.solve(es_problem)

    # 5) Zeitentwicklung
    sv = Statevector(vqe_result.eigenstate)
    evo = PauliTrotterEvolution().convert(StateFn(qubit_hamiltonian).exp_i())

    statevectors, prob_history, entropy_history, fidelity_history = [], [], [], []
    for step in range(trotter_steps):
        t = step * time_step

        # Geodrift
        qc_drift = QuantumCircuit(num_qubits)
        drift_values = geodrift(t, num_qubits, amplitude=geodrift_amplitude)
        for q in range(num_qubits):
            qc_drift.rz(2*drift_values[q], q)
        sv = sv.evolve(qc_drift)

        # Hamiltonian-Evolution
        sv = sv.evolve(evo)

        # Metriken
        probs = sv.probabilities_dict()
        keys = sorted(probs.keys())
        prob_history.append({k: float(probs[k]) for k in keys})
        entropy_history.append([compute_von_neumann_entropy(sv, q) for q in range(num_qubits)])
        fidelity_history.append(float(state_fidelity(sv, vqe_result.eigenstate)))
        statevectors.append(sv)

    # 6) Export
    out_json = {
        "probabilities": prob_history,
        "entropy": entropy_history,
        "fidelity": fidelity_history,
        "meta": {
            "atoms": atom_list,
            "basis": basis,
            "active_electrons": active_electrons,
            "active_orbitals": active_orbitals,
            "num_qubits": num_qubits,
            "trotter_steps": trotter_steps,
            "time_step": time_step,
            "geodrift_amplitude": geodrift_amplitude
        }
    }
    with open(f"{name}_simulation_results.json", "w") as f:
        json.dump(out_json, f, indent=2)

    return {
        "name": name,
        "num_qubits": num_qubits,
        "vqe_result": vqe_result,
        "statevectors": statevectors,
        "prob_history": prob_history,
        "entropy_history": entropy_history,
        "fidelity_history": fidelity_history
    }

# --- Plotly-Visualisierung ---------------------------------------------------
def visualize_simulation(result):
    frames = []
    for step, sv in enumerate(result["statevectors"]):
        num_qubits = result["num_qubits"]
        probs_dict = result["prob_history"][step]
        states = list(probs_dict.keys())
        probs = [probs_dict[s] for s in states]  # bereits normiert
        entropy_vals = np.array(result["entropy_history"][step]).reshape((1, num_qubits))
        ent_matrix = compute_concurrence_matrix(sv, num_qubits)
        fidelity = result["fidelity_history"][step]

        frame = go.Frame(
            data=[
                go.Bar(
                    x=states, y=probs, name="Wahrscheinlichkeiten",
                    marker_color='royalblue',
                    hovertemplate="Zustand: %{x}<br>Wahrscheinlichkeit: %{y:.3f}<extra></extra>"
                ),
                go.Heatmap(
                    z=entropy_vals, x=[f"Q{q}" for q in range(num_qubits)], y=["Entropie"],
                    colorscale='Viridis', zmin=0, zmax=1,
                    hovertemplate="Qubit %{x}<br>Entropie: %{z:.3f}<extra></extra>"
                ),
                go.Heatmap(
                    z=ent_matrix,
                    x=[f"Q{q}" for q in range(num_qubits)],
                    y=[f"Q{q}" for q in range(num_qubits)],
                    colorscale='Cividis', zmin=0, zmax=1,
                    hovertemplate="Qubit %{x} ↔ %{y}<br>Concurrence: %{z:.3f}<extra></extra>"
                ),
                go.Indicator(
                    mode="gauge+number", value=fidelity,
                    title={"text": "Fidelity zum Grundzustand"},
                    gauge={"axis": {"range": [0, 1]}}
                )
            ],
            name=f"Step {step+1}"
        )
        frames.append(frame)

    fig = go.Figure(
        data=frames[0].data,
        layout=go.Layout(
            title=f"🧪 {result['name']} — Wahrscheinlichkeiten, Entropie, Concurrence, Fidelity",
            height=750,
            updatemenus=[dict(
                type="buttons", showactive=False,
                buttons=[
                    dict(label="▶️ Play", method="animate",
                         args=[None, {"frame": {"duration": 800}, "fromcurrent": True}]),
                    dict(label="⏹️ Stop", method="animate",
                         args=[[None], {"frame": {"duration": 0}, "mode": "immediate"}])
                ]
            )],
            sliders=[dict(
                steps=[dict(
                    method="animate",
                    args=[[f"Step {i+1}"], {"frame": {"duration": 0}, "mode": "immediate"}],
                    label=f"{i+1}"
                ) for i in range(len(frames))],
                transition={"duration": 0},
                x=0.1, y=0,
                currentvalue={"prefix": "Trotter-Schritt: ", "font": {"size": 16}},
                len=0.9
            )]
        ),
        frames=frames
    )

    fig.show()
    fig.write_html(f"{result['name']}_simulation_visualisierung.html")
    print(f"💾 Visualisierung gespeichert: {result['name']}_simulation_visualisierung.html")

# --- Main --------------------------------------------------------------------
if __name__ == "__main__":
    # Beispiel-Systeme (beliebig erweiterbar)
    systems = [
        ["H", "H"],          # H2
        ["Li", "H"],         # LiH
        ["Be", "H", "H"],    # BeH2 (linear)
        ["Ne"],              # Einzelatom (kleines Basisset)
        # Hinweis: Für sehr schwere Atome wie Pu braucht man relativistische ECPs & große Basissätze.
    ]

    for atoms in systems:
        tag = "".join(atoms)
        try:
            print(f"\n=== Starte Simulation: {tag} ===")
            result = run_universal_molecule_simulation(atoms, basis=BASIS_DEFAULT)
            visualize_simulation(result)
            print(f"✓ Fertig: {tag} — JSON + HTML erstellt.")
        except Exception as e:
            print(f"❌ Fehler bei {tag}: {e}")
